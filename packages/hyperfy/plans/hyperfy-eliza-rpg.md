# Hyperfy-Eliza RPG System Implementation Report

## Executive Summary

This report outlines the implementation strategy for building a comprehensive RPG system within the Hyperfy metaverse platform, integrated with Eliza AI agents. The system will include mobile NPCs, combat mechanics, loot systems, progression mechanics, and AI-generated quests.

## Table of Contents

1. [Architecture Overview](#architecture-overview)
2. [Core Systems Analysis](#core-systems-analysis)
3. [Implementation Plan](#implementation-plan)
4. [System Components](#system-components)
5. [Integration Points](#integration-points)
6. [Technical Specifications](#technical-specifications)
7. [Development Roadmap](#development-roadmap)

## Architecture Overview

### Current Hyperfy Architecture

Based on the codebase analysis, Hyperfy uses:

- **Entity Component System (ECS)**: Core game objects are entities with components
- **Node-based Scene Graph**: Hierarchical 3D scene management
- **Physics System**: PhysX integration for collision and dynamics
- **Network Layer**: Real-time multiplayer synchronization
- **Plugin Architecture**: Extensible system for adding features
- **Event System**: Decoupled communication between systems

### Proposed RPG Architecture

The RPG system will be implemented as a Hyperfy plugin with the following core modules:

```
hyperfy-rpg-plugin/
├── src/
│   ├── systems/
│   │   ├── CombatSystem.ts
│   │   ├── LootSystem.ts
│   │   ├── ProgressionSystem.ts
│   │   ├── QuestSystem.ts
│   │   └── NPCSystem.ts
│   ├── components/
│   │   ├── Stats.ts
│   │   ├── Inventory.ts
│   │   ├── Combat.ts
│   │   ├── NPC.ts
│   │   └── Quest.ts
│   ├── entities/
│   │   ├── Mob.ts
│   │   ├── Chest.ts
│   │   ├── NPCQuestGiver.ts
│   │   └── LootDrop.ts
│   └── eliza/
│       ├── QuestGenerator.ts
│       └── NPCDialogue.ts
```

## Core Systems Analysis

### 1. Entity System Integration

Hyperfy's entity system provides the foundation for RPG entities:

```typescript
// Current entity structure
interface Entity {
  id: string
  name: string
  type: string
  node: any // THREE.Object3D
  components: Map<string, Component>
  data: Record<string, any>
}
```

This will be extended for RPG entities with specialized components.

### 2. Component Architecture

New components needed for RPG functionality:

```typescript
// Stats Component
interface StatsComponent extends Component {
  hp: number
  maxHp: number
  mana: number
  maxMana: number
  xp: number
  level: number
  armor: number
  damage: number
}

// Inventory Component
interface InventoryComponent extends Component {
  items: Item[]
  equipment: {
    weapon?: Weapon
    armor?: Armor
    accessories?: Accessory[]
  }
  capacity: number
}

// NPC Component
interface NPCComponent extends Component {
  behavior: 'patrol' | 'wander' | 'stationary' | 'follow'
  dialogue: DialogueTree
  questsOffered: Quest[]
  faction: string
  aggression: number
}
```

### 3. System Integration Points

Key integration points with existing Hyperfy systems:

- **Physics System**: Combat collision detection, projectiles
- **Network System**: Synchronizing combat, loot, and progression
- **Event System**: Quest triggers, combat events, death/respawn
- **Chat System**: NPC dialogue, quest notifications
- **Storage System**: Persistent player progression

## Implementation Plan

### Phase 1: Core RPG Components

#### 1.1 Stats and Combat System

```typescript
export class CombatSystem extends System {
  private combatants: Map<string, CombatState> = new Map()

  update(delta: number): void {
    // Process ongoing combat
    for (const [entityId, combat] of this.combatants) {
      this.processCombat(entityId, combat, delta)
    }
  }

  attack(attackerId: string, targetId: string, skill?: Skill): void {
    const attacker = this.world.entities.get(attackerId)
    const target = this.world.entities.get(targetId)

    if (!attacker || !target) return

    const damage = this.calculateDamage(attacker, target, skill)
    this.applyDamage(target, damage, attacker)

    // Emit combat event
    this.world.events.emit('combat:attack', {
      attacker: attackerId,
      target: targetId,
      damage,
      skill,
    })
  }

  private calculateDamage(attacker: Entity, target: Entity, skill?: Skill): number {
    const attackerStats = attacker.getComponent<StatsComponent>('stats')
    const targetStats = target.getComponent<StatsComponent>('stats')

    let baseDamage = attackerStats.damage
    if (skill) {
      baseDamage = skill.calculateDamage(attackerStats)
    }

    const defense = targetStats.armor
    const finalDamage = Math.max(1, baseDamage - defense)

    return finalDamage
  }
}
```

#### 1.2 Death and Respawn System

```typescript
export class RespawnSystem extends System {
  private respawnQueue: Map<string, RespawnData> = new Map()
  private respawnDelay = 5000 // 5 seconds

  handleDeath(entityId: string): void {
    const entity = this.world.entities.get(entityId)
    if (!entity) return

    const stats = entity.getComponent<StatsComponent>('stats')
    if (!stats) return

    // Calculate XP penalty (lose half of current level's XP)
    const currentLevelXP = this.getXPForLevel(stats.level)
    const nextLevelXP = this.getXPForLevel(stats.level + 1)
    const levelProgress = stats.xp - currentLevelXP
    const xpLoss = Math.floor(levelProgress / 2)

    // Queue for respawn
    this.respawnQueue.set(entityId, {
      timestamp: Date.now(),
      xpLoss,
      spawnPoint: this.getSpawnPoint(entity),
    })

    // Emit death event
    this.world.events.emit('player:death', {
      entityId,
      xpLoss,
    })
  }

  update(delta: number): void {
    const now = Date.now()

    for (const [entityId, respawnData] of this.respawnQueue) {
      if (now - respawnData.timestamp >= this.respawnDelay) {
        this.respawn(entityId, respawnData)
        this.respawnQueue.delete(entityId)
      }
    }
  }
}
```

### Phase 2: Loot and Inventory System

#### 2.1 Loot Table System

```typescript
interface LootTable {
  id: string
  entries: LootEntry[]
}

interface LootEntry {
  item: ItemTemplate
  weight: number
  minQuantity: number
  maxQuantity: number
  conditions?: LootCondition[]
}

export class LootSystem extends System {
  private lootTables: Map<string, LootTable> = new Map()

  generateLoot(tableId: string, modifiers?: LootModifiers): Item[] {
    const table = this.lootTables.get(tableId)
    if (!table) return []

    const loot: Item[] = []
    const rolls = modifiers?.extraRolls || 1

    for (let i = 0; i < rolls; i++) {
      const entry = this.selectWeightedEntry(table.entries)
      if (entry && this.checkConditions(entry.conditions)) {
        const quantity = this.randomInt(entry.minQuantity, entry.maxQuantity)
        for (let j = 0; j < quantity; j++) {
          loot.push(this.createItem(entry.item))
        }
      }
    }

    return loot
  }

  dropLoot(position: Vector3, loot: Item[]): void {
    for (const item of loot) {
      const offset = {
        x: (Math.random() - 0.5) * 2,
        y: 0.5,
        z: (Math.random() - 0.5) * 2,
      }

      const dropEntity = this.world.entities.create('LootDrop', {
        position: {
          x: position.x + offset.x,
          y: position.y + offset.y,
          z: position.z + offset.z,
        },
        item,
      })

      // Add physics for drop animation
      const rigidbody = dropEntity.getComponent('rigidbody')
      if (rigidbody) {
        rigidbody.applyImpulse({
          x: offset.x * 2,
          y: 5,
          z: offset.z * 2,
        })
      }
    }
  }
}
```

#### 2.2 Chest Implementation

```typescript
export class ChestEntity extends Entity {
  private lootTableId: string
  private isOpen: boolean = false
  private respawnTime: number = 300000 // 5 minutes

  constructor(world: World, options: ChestOptions) {
    super(world, 'chest', options)

    this.lootTableId = options.lootTableId

    // Add interactable component
    this.addComponent('interactable', {
      range: 3,
      prompt: 'Press E to open chest',
      onInteract: this.open.bind(this),
    })

    // Add visual representation
    this.addComponent('mesh', {
      geometry: 'box',
      material: 'chest',
      scale: { x: 1, y: 0.8, z: 0.6 },
    })
  }

  open(interactor: Entity): void {
    if (this.isOpen) return

    const lootSystem = this.world.getSystem<LootSystem>('loot')
    const loot = lootSystem.generateLoot(this.lootTableId)

    // Give loot to interactor
    const inventory = interactor.getComponent<InventoryComponent>('inventory')
    if (inventory) {
      for (const item of loot) {
        inventory.addItem(item)
      }
    }

    this.isOpen = true
    this.scheduleRespawn()

    // Update visual
    this.updateVisual('open')

    // Emit event
    this.world.events.emit('chest:opened', {
      chestId: this.id,
      interactorId: interactor.id,
      loot,
    })
  }
}
```

### Phase 3: NPC and Mob System

#### 3.1 Mobile NPC Implementation

```typescript
export class NPCSystem extends System {
  private npcs: Map<string, NPCEntity> = new Map()

  spawnNPC(template: NPCTemplate, position: Vector3): NPCEntity {
    const npc = new NPCEntity(this.world, {
      ...template,
      position,
    })

    this.npcs.set(npc.id, npc)

    // Add AI behavior
    npc.addComponent('ai', {
      behavior: template.behavior,
      patrolPath: template.patrolPath,
      aggressionRadius: template.aggressionRadius,
    })

    // Add dialogue for quest givers
    if (template.isQuestGiver) {
      npc.addComponent('questGiver', {
        quests: template.quests,
        dialogue: template.dialogue,
      })
    }

    return npc
  }

  update(delta: number): void {
    for (const [id, npc] of this.npcs) {
      this.updateNPCBehavior(npc, delta)
    }
  }

  private updateNPCBehavior(npc: NPCEntity, delta: number): void {
    const ai = npc.getComponent<AIComponent>('ai')
    if (!ai) return

    switch (ai.behavior) {
      case 'patrol':
        this.updatePatrol(npc, ai, delta)
        break
      case 'wander':
        this.updateWander(npc, ai, delta)
        break
      case 'aggressive':
        this.updateAggressive(npc, ai, delta)
        break
    }
  }
}
```

#### 3.2 Mob Spawning System

```typescript
export class MobSpawner extends System {
  private spawners: SpawnerConfig[] = []
  private activeMobs: Map<string, MobEntity> = new Map()
  private maxMobsPerSpawner = 5

  registerSpawner(config: SpawnerConfig): void {
    this.spawners.push({
      ...config,
      lastSpawn: 0,
      currentMobs: new Set(),
    })
  }

  update(delta: number): void {
    const now = Date.now()

    for (const spawner of this.spawners) {
      // Check if we should spawn
      if (spawner.currentMobs.size < this.maxMobsPerSpawner && now - spawner.lastSpawn > spawner.spawnInterval) {
        // Check for nearby players
        const nearbyPlayers = this.getPlayersInRange(spawner.position, spawner.activationRange)

        if (nearbyPlayers.length > 0) {
          this.spawnMob(spawner)
          spawner.lastSpawn = now
        }
      }

      // Clean up dead mobs
      for (const mobId of spawner.currentMobs) {
        if (!this.activeMobs.has(mobId)) {
          spawner.currentMobs.delete(mobId)
        }
      }
    }
  }

  private spawnMob(spawner: SpawnerConfig): void {
    const template = this.selectMobTemplate(spawner.mobTemplates)
    const spawnPos = this.getRandomSpawnPosition(spawner)

    const mob = new MobEntity(this.world, {
      ...template,
      position: spawnPos,
      onDeath: () => {
        this.handleMobDeath(mob, spawner)
      },
    })

    this.activeMobs.set(mob.id, mob)
    spawner.currentMobs.add(mob.id)

    // Emit spawn event
    this.world.events.emit('mob:spawn', {
      mobId: mob.id,
      spawnerId: spawner.id,
      position: spawnPos,
    })
  }
}
```

### Phase 4: Quest System with Eliza Integration

#### 4.1 Quest Generation with Eliza

```typescript
export class ElizaQuestGenerator {
  private elizaRuntime: IAgentRuntime
  private worldContext: WorldContext

  constructor(runtime: IAgentRuntime, world: World) {
    this.elizaRuntime = runtime
    this.worldContext = this.buildWorldContext(world)
  }

  async generateQuest(player: PlayerEntity): Promise<Quest> {
    // Gather context about the player and world
    const context = {
      playerLevel: player.stats.level,
      playerClass: player.class,
      availableMobs: this.worldContext.mobs,
      availableItems: this.worldContext.items,
      availableNPCs: this.worldContext.npcs,
      recentQuests: player.questHistory.slice(-5),
    }

    // Create prompt for Eliza
    const prompt = `Generate a quest for a level ${context.playerLevel} ${context.playerClass}.
    Available elements:
    - Mobs: ${context.availableMobs.map(m => m.name).join(', ')}
    - Items: ${context.availableItems.map(i => i.name).join(', ')}
    - NPCs: ${context.availableNPCs.map(n => n.name).join(', ')}
    
    The quest should be engaging, level-appropriate, and use available world elements.
    Avoid similar quests to: ${context.recentQuests.map(q => q.summary).join('; ')}`

    // Generate quest using Eliza
    const response = await this.elizaRuntime.completion({
      messages: [
        {
          role: 'system',
          content: 'You are a quest designer for an RPG game. Create engaging quests using available world elements.',
        },
        {
          role: 'user',
          content: prompt,
        },
      ],
    })

    // Parse response into quest structure
    return this.parseQuestResponse(response, context)
  }

  private parseQuestResponse(response: string, context: any): Quest {
    // Parse Eliza's response into structured quest data
    const quest: Quest = {
      id: generateId(),
      title: this.extractTitle(response),
      description: this.extractDescription(response),
      objectives: this.extractObjectives(response, context),
      rewards: this.generateRewards(context.playerLevel),
      dialogue: {
        start: this.extractStartDialogue(response),
        progress: this.extractProgressDialogue(response),
        complete: this.extractCompleteDialogue(response),
      },
      level: context.playerLevel,
      generatedAt: Date.now(),
    }

    return quest
  }
}
```

#### 4.2 Quest Tracking System

```typescript
export class QuestSystem extends System {
  private activeQuests: Map<string, QuestInstance> = new Map()
  private questGenerator: ElizaQuestGenerator

  async assignQuest(playerId: string, questGiverId: string): Promise<void> {
    const player = this.world.entities.get(playerId)
    const questGiver = this.world.entities.get(questGiverId)

    if (!player || !questGiver) return

    // Generate quest using Eliza
    const quest = await this.questGenerator.generateQuest(player)

    // Create quest instance
    const instance: QuestInstance = {
      quest,
      playerId,
      questGiverId,
      startTime: Date.now(),
      progress: this.initializeProgress(quest),
      status: 'active',
    }

    this.activeQuests.set(instance.id, instance)

    // Add to player's quest log
    const questLog = player.getComponent<QuestLogComponent>('questLog')
    questLog.addQuest(instance)

    // Start dialogue
    this.world.chat.sendNPCMessage(questGiver, player, quest.dialogue.start)
  }

  updateQuestProgress(playerId: string, event: QuestEvent): void {
    const playerQuests = this.getPlayerQuests(playerId)

    for (const instance of playerQuests) {
      for (const objective of instance.quest.objectives) {
        if (this.matchesObjective(event, objective)) {
          instance.progress[objective.id]++

          if (this.isObjectiveComplete(instance, objective)) {
            this.world.events.emit('quest:objective-complete', {
              playerId,
              questId: instance.quest.id,
              objectiveId: objective.id,
            })
          }

          if (this.isQuestComplete(instance)) {
            this.completeQuest(instance)
          }
        }
      }
    }
  }
}
```

### Phase 5: Progression System

#### 5.1 Level and XP System

```typescript
export class ProgressionSystem extends System {
  private xpFormula = (level: number) => Math.floor(100 * Math.pow(1.5, level - 1))

  grantXP(entityId: string, amount: number, source?: string): void {
    const entity = this.world.entities.get(entityId)
    if (!entity) return

    const stats = entity.getComponent<StatsComponent>('stats')
    if (!stats) return

    stats.xp += amount

    // Check for level up
    while (stats.xp >= this.xpFormula(stats.level + 1)) {
      this.levelUp(entity, stats)
    }

    // Emit XP gain event
    this.world.events.emit('xp:gained', {
      entityId,
      amount,
      source,
      newTotal: stats.xp,
      level: stats.level,
    })
  }

  private levelUp(entity: Entity, stats: StatsComponent): void {
    stats.level++

    // Increase base stats
    stats.maxHp += 10 + stats.level * 2
    stats.hp = stats.maxHp // Full heal on level up
    stats.maxMana += 5 + stats.level
    stats.mana = stats.maxMana
    stats.damage += 2
    stats.armor += 1

    // Unlock new abilities
    this.unlockAbilities(entity, stats.level)

    // Visual effect
    this.world.effects.play('levelUp', entity.position)

    // Notification
    this.world.events.emit('player:levelup', {
      entityId: entity.id,
      newLevel: stats.level,
    })
  }
}
```

#### 5.2 Spell and Ability System

```typescript
export class SpellSystem extends System {
  private spells: Map<string, SpellTemplate> = new Map()
  private cooldowns: Map<string, Map<string, number>> = new Map()

  castSpell(casterId: string, spellId: string, target?: Vector3 | string): void {
    const caster = this.world.entities.get(casterId)
    if (!caster) return

    const spell = this.spells.get(spellId)
    if (!spell) return

    // Check requirements
    if (!this.canCast(caster, spell)) return

    // Consume mana
    const stats = caster.getComponent<StatsComponent>('stats')
    stats.mana -= spell.manaCost

    // Apply cooldown
    this.setCooldown(casterId, spellId, spell.cooldown)

    // Execute spell effect
    this.executeSpell(caster, spell, target)

    // Emit cast event
    this.world.events.emit('spell:cast', {
      casterId,
      spellId,
      target,
    })
  }

  private executeSpell(caster: Entity, spell: SpellTemplate, target?: Vector3 | string): void {
    switch (spell.type) {
      case 'projectile':
        this.castProjectile(caster, spell, target)
        break
      case 'aoe':
        this.castAOE(caster, spell, target as Vector3)
        break
      case 'buff':
        this.castBuff(caster, spell, target as string)
        break
      case 'summon':
        this.castSummon(caster, spell, target as Vector3)
        break
    }
  }
}
```

## Integration Points

### 1. Eliza Integration for Dynamic Content

```typescript
export class ElizaNPCDialogue {
  private runtime: IAgentRuntime

  async generateDialogue(npc: NPCEntity, player: PlayerEntity, context: DialogueContext): Promise<string> {
    const prompt = this.buildPrompt(npc, player, context)

    const response = await this.runtime.completion({
      messages: [
        {
          role: 'system',
          content: `You are ${npc.name}, ${npc.description}. Respond in character.`,
        },
        {
          role: 'user',
          content: prompt,
        },
      ],
      temperature: 0.8,
      maxTokens: 150,
    })

    return this.processResponse(response, npc)
  }
}
```

### 2. Network Synchronization

```typescript
export class RPGNetworkSync extends System {
  syncCombat(event: CombatEvent): void {
    this.world.network.broadcast('rpg:combat', {
      type: event.type,
      attacker: event.attacker,
      target: event.target,
      damage: event.damage,
      effects: event.effects,
    })
  }

  syncLoot(event: LootEvent): void {
    this.world.network.broadcast('rpg:loot', {
      type: 'drop',
      position: event.position,
      items: event.items,
      owner: event.owner,
    })
  }

  syncProgression(event: ProgressionEvent): void {
    this.world.network.send(event.playerId, 'rpg:progression', {
      xp: event.xp,
      level: event.level,
      stats: event.stats,
    })
  }
}
```

### 3. Persistence Layer

```typescript
export class RPGPersistence {
  async savePlayerData(playerId: string, data: PlayerRPGData): Promise<void> {
    const compressed = this.compressData(data)
    await this.world.storage.set(`rpg:player:${playerId}`, compressed)
  }

  async loadPlayerData(playerId: string): Promise<PlayerRPGData | null> {
    const compressed = await this.world.storage.get(`rpg:player:${playerId}`)
    if (!compressed) return null

    return this.decompressData(compressed)
  }
}
```

## Technical Specifications

### Data Models

```typescript
// Item System
interface Item {
  id: string
  templateId: string
  name: string
  type: 'weapon' | 'armor' | 'consumable' | 'material' | 'quest'
  rarity: 'common' | 'uncommon' | 'rare' | 'epic' | 'legendary'
  stats?: ItemStats
  effects?: ItemEffect[]
  stackable: boolean
  maxStack: number
  value: number
}

interface Weapon extends Item {
  type: 'weapon'
  weaponType: 'sword' | 'bow' | 'staff' | 'dagger'
  damage: DamageRange
  attackSpeed: number
  range: number
}

interface Armor extends Item {
  type: 'armor'
  armorType: 'helmet' | 'chest' | 'legs' | 'boots' | 'gloves'
  defense: number
  resistances?: Resistances
}

// Quest System
interface Quest {
  id: string
  title: string
  description: string
  level: number
  objectives: QuestObjective[]
  rewards: QuestRewards
  dialogue: QuestDialogue
  prerequisites?: QuestPrerequisite[]
}

interface QuestObjective {
  id: string
  type: 'kill' | 'collect' | 'interact' | 'reach' | 'survive'
  description: string
  target: string
  quantity: number
  location?: Vector3
  timeLimit?: number
}

// Combat System
interface CombatStats {
  damage: number
  attackSpeed: number
  critChance: number
  critMultiplier: number
  accuracy: number
  evasion: number
  blockChance: number
  resistances: Resistances
}

interface Spell {
  id: string
  name: string
  description: string
  type: 'damage' | 'heal' | 'buff' | 'debuff' | 'summon'
  manaCost: number
  cooldown: number
  castTime: number
  range: number
  effects: SpellEffect[]
}
```

### Performance Considerations

1. **Entity Pooling**: Reuse entities for mobs and loot drops
2. **LOD System**: Reduce detail for distant RPG elements
3. **Spatial Indexing**: Efficient queries for nearby entities
4. **Network Optimization**: Delta compression for stat updates
5. **Async Quest Generation**: Non-blocking Eliza integration

### Security Considerations

1. **Server Validation**: All combat and loot calculations server-side
2. **Anti-Cheat**: Validate movement speed, damage output
3. **Rate Limiting**: Prevent spam of abilities and interactions
4. **Secure Random**: Cryptographically secure loot generation

## Development Roadmap

### Phase 1: Foundation (Weeks 1-2)

- [ ] Implement basic stats component
- [ ] Create combat system with melee attacks
- [ ] Add death/respawn mechanics
- [ ] Basic XP and leveling

### Phase 2: Loot & Inventory (Weeks 3-4)

- [ ] Implement inventory system
- [ ] Create loot tables and drop system
- [ ] Add chest entities
- [ ] Item equipping and stats modification

### Phase 3: NPCs & Mobs (Weeks 5-6)

- [ ] Mobile NPC system with behaviors
- [ ] Mob spawner implementation
- [ ] Basic AI for combat and pathing
- [ ] Aggression and faction system

### Phase 4: Quest System (Weeks 7-8)

- [ ] Quest data models and tracking
- [ ] Eliza integration for quest generation
- [ ] Quest UI and notifications
- [ ] Objective detection and completion

### Phase 5: Advanced Features (Weeks 9-10)

- [ ] Spell and ability system
- [ ] Weapon types and combat styles
- [ ] Armor and resistance system
- [ ] Mana and resource management

### Phase 6: Polish & Optimization (Weeks 11-12)

- [ ] Performance optimization
- [ ] Visual effects and animations
- [ ] Balance testing and tuning
- [ ] Bug fixes and edge cases

## Conclusion

This comprehensive RPG system leverages Hyperfy's existing architecture while adding deep gameplay mechanics through modular, extensible systems. The integration with Eliza enables dynamic, AI-generated content that keeps the game fresh and engaging. The phased development approach ensures each system is properly tested before building upon it.

Key success factors:

- Modular architecture allows incremental development
- Eliza integration provides unlimited content variety
- Network-first design ensures smooth multiplayer
- Performance considerations built in from the start
- Extensible systems allow future feature additions

The system is designed to scale from small player counts to massive multiplayer scenarios while maintaining performance and gameplay quality.
